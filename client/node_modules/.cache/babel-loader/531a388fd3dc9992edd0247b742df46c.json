{"ast":null,"code":"\"use strict\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDependencyArrayRef = void 0;\n/**\r\n * useEffect(\r\n *    ()=> { ... },\r\n *    [ { \"foo\": \"bar\" } ]\r\n * )\r\n * => The callback will be invoked every render.\r\n * because { \"foo\": \"bar\" } is a new instance every render.\r\n *\r\n * useEffect(\r\n *    ()=> { ... },\r\n *    [ getDependencyArrayRef({ \"foo\": \"bar\" }) ]\r\n * );\r\n * => The callback will only be invoked once.\r\n *\r\n * The optimization will be enabled only if obj is\r\n * of the form Record<string, string | number | undefined | null>\r\n * overwise the object is returned (the function is the identity function).\r\n */\nfunction getDependencyArrayRef(obj) {\n  if (!(obj instanceof Object) || typeof obj === \"function\") {\n    return obj;\n  }\n  const arr = [];\n  for (const key in obj) {\n    const value = obj[key];\n    const typeofValue = typeof value;\n    if (!(typeofValue === \"string\" || typeofValue === \"number\" && !isNaN(value) || typeofValue === \"boolean\" || value === undefined || value === null)) {\n      return obj;\n    }\n    arr.push(`${key}:${typeofValue}_${value}`);\n  }\n  return \"xSqLiJdLMd9s\" + arr.join(\"|\");\n}\nexports.getDependencyArrayRef = getDependencyArrayRef;","map":{"version":3,"names":["Object","defineProperty","exports","value","getDependencyArrayRef","obj","arr","key","typeofValue","isNaN","undefined","push","join"],"sources":["C:/Users/1867792/up_pro/client/node_modules/tss-react/tools/getDependencyArrayRef.js"],"sourcesContent":["\"use strict\";\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getDependencyArrayRef = void 0;\r\n/**\r\n * useEffect(\r\n *    ()=> { ... },\r\n *    [ { \"foo\": \"bar\" } ]\r\n * )\r\n * => The callback will be invoked every render.\r\n * because { \"foo\": \"bar\" } is a new instance every render.\r\n *\r\n * useEffect(\r\n *    ()=> { ... },\r\n *    [ getDependencyArrayRef({ \"foo\": \"bar\" }) ]\r\n * );\r\n * => The callback will only be invoked once.\r\n *\r\n * The optimization will be enabled only if obj is\r\n * of the form Record<string, string | number | undefined | null>\r\n * overwise the object is returned (the function is the identity function).\r\n */\r\nfunction getDependencyArrayRef(obj) {\r\n    if (!(obj instanceof Object) || typeof obj === \"function\") {\r\n        return obj;\r\n    }\r\n    const arr = [];\r\n    for (const key in obj) {\r\n        const value = obj[key];\r\n        const typeofValue = typeof value;\r\n        if (!(typeofValue === \"string\" ||\r\n            (typeofValue === \"number\" && !isNaN(value)) ||\r\n            typeofValue === \"boolean\" ||\r\n            value === undefined ||\r\n            value === null)) {\r\n            return obj;\r\n        }\r\n        arr.push(`${key}:${typeofValue}_${value}`);\r\n    }\r\n    return \"xSqLiJdLMd9s\" + arr.join(\"|\");\r\n}\r\nexports.getDependencyArrayRef = getDependencyArrayRef;\r\n"],"mappings":"AAAA,YAAY;;AACZ;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,qBAAqB,GAAG,KAAK,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,qBAAqB,CAACC,GAAG,EAAE;EAChC,IAAI,EAAEA,GAAG,YAAYL,MAAM,CAAC,IAAI,OAAOK,GAAG,KAAK,UAAU,EAAE;IACvD,OAAOA,GAAG;EACd;EACA,MAAMC,GAAG,GAAG,EAAE;EACd,KAAK,MAAMC,GAAG,IAAIF,GAAG,EAAE;IACnB,MAAMF,KAAK,GAAGE,GAAG,CAACE,GAAG,CAAC;IACtB,MAAMC,WAAW,GAAG,OAAOL,KAAK;IAChC,IAAI,EAAEK,WAAW,KAAK,QAAQ,IACzBA,WAAW,KAAK,QAAQ,IAAI,CAACC,KAAK,CAACN,KAAK,CAAE,IAC3CK,WAAW,KAAK,SAAS,IACzBL,KAAK,KAAKO,SAAS,IACnBP,KAAK,KAAK,IAAI,CAAC,EAAE;MACjB,OAAOE,GAAG;IACd;IACAC,GAAG,CAACK,IAAI,CAAE,GAAEJ,GAAI,IAAGC,WAAY,IAAGL,KAAM,EAAC,CAAC;EAC9C;EACA,OAAO,cAAc,GAAGG,GAAG,CAACM,IAAI,CAAC,GAAG,CAAC;AACzC;AACAV,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB"},"metadata":{},"sourceType":"script"}